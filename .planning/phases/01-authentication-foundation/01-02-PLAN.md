---
phase: 01-authentication-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [rag_web.py]
autonomous: false
---

<objective>
Integrate streamlit-authenticator into existing Streamlit web UI (rag_web.py) to require username/password authentication before accessing RAG functionality.

Purpose: Transform web UI from localhost-only to production-ready with secure access control. Users must authenticate before querying documents.

Output: Authenticated Streamlit web UI with login page, logout button, session management, and protected RAG interface.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/1-authentication-foundation/1-RESEARCH.md
@.planning/phases/01-authentication-foundation/01-01-SUMMARY.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@rag_web.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap Streamlit app with authentication</name>
  <files>rag_web.py</files>
  <action>
    Modify rag_web.py to add authentication at the top of the file (before any RAG UI code):

    1. Add imports at top of file:
    ```python
    import streamlit as st
    from auth.authenticator import load_authenticator
    ```

    2. After imports, before any UI code, add authentication logic (from research Pattern 1):
    ```python
    # Initialize authenticator
    authenticator = load_authenticator()

    # Render login widget
    name, authentication_status, username = authenticator.login('main')

    # Handle authentication states
    if authentication_status:
        # User authenticated - show logout in sidebar
        authenticator.logout('Logout', 'sidebar')
        st.sidebar.write(f'Welcome *{name}*')

        # --- EXISTING RAG UI CODE GOES HERE (indented under if block) ---
        # All existing st.title(), st.text_input(), query handling stays the same
        # Just indent everything that was previously at module level

    elif authentication_status is False:
        st.error('Username/password is incorrect')
        st.stop()

    elif authentication_status is None:
        st.warning('Please enter your username and password')
        st.stop()
    ```

    3. Indent all existing RAG UI code (everything that creates the query interface) under the `if authentication_status:` block

    Why st.stop(): Prevents execution of UI code when user is not authenticated. Research shows this is the recommended pattern for Streamlit authentication.

    Why logout in sidebar: Standard pattern from streamlit-authenticator - keeps main area for RAG UI, sidebar for user controls.
  </action>
  <verify>
    - `python -c "import rag_web"` succeeds (no syntax errors)
    - `grep "authenticator.login" rag_web.py` shows authentication code present
    - `grep "st.stop()" rag_web.py` shows protection on non-authenticated states
  </verify>
  <done>rag_web.py wrapped with authentication, login page shown before RAG interface</done>
</task>

<task type="auto">
  <name>Task 2: Add session state management</name>
  <files>rag_web.py</files>
  <action>
    Streamlit-authenticator automatically manages session state, but we should verify session persistence:

    Add session state checks after authentication block (inside `if authentication_status:` block):

    ```python
    # Store user info in session state for access throughout app
    if 'username' not in st.session_state:
        st.session_state['username'] = username
    if 'name' not in st.session_state:
        st.session_state['name'] = name
    ```

    This allows other parts of the app to access user info via `st.session_state['username']` if needed for logging or personalization.

    Why session_state: Research shows Streamlit's session_state is the standard way to persist data across reruns. streamlit-authenticator uses it for authentication status.

    Note: Do NOT load untrusted data into session_state - pickle deserialization vulnerability (research pitfall #1). Only use for data we control (username, name from our config).
  </action>
  <verify>
    - Code includes `st.session_state['username'] = username` inside authentication block
    - No user input directly loaded into session_state without validation
  </verify>
  <done>Session state management added for user info persistence</done>
</task>

<task type="auto">
  <name>Task 3: Test authentication flow locally</name>
  <files>rag_web.py</files>
  <action>
    Run Streamlit app locally to verify authentication before human checkpoint:

    ```bash
    streamlit run rag_web.py
    ```

    Automated checks:
    1. Verify app starts without errors
    2. Check console output for any warnings about authentication
    3. Verify no Python tracebacks in terminal

    Do NOT test login functionality yet - that's for the checkpoint in next task.

    If errors occur:
    - Check import paths (auth.authenticator module)
    - Verify auth/config.yaml exists and is readable
    - Check cookie key is configured

    Why separate automated checks: We can verify technical correctness (no crashes, imports work) before human tests functional correctness (login works).
  </action>
  <verify>
    - `streamlit run rag_web.py` starts without errors
    - No Python tracebacks in console
    - Browser opens to Streamlit app (may see login form or error page, both OK)
  </verify>
  <done>Streamlit app starts successfully with authentication code integrated</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Authenticated Streamlit web UI with login page, logout functionality, and protected RAG interface</what-built>
  <how-to-verify>
    1. Run: streamlit run rag_web.py
    2. Visit: http://localhost:8501 (should open automatically)
    3. Verify login page appears with username/password fields
    4. Test invalid login: Enter wrong credentials, verify error message "Username/password is incorrect"
    5. Test valid login: Enter credentials from auth/config.yaml (username: admin, password: change_me_on_first_login)
    6. Verify successful login:
       - Login form disappears
       - RAG query interface appears (text input, buttons)
       - Sidebar shows "Welcome *Admin User*" message
       - Sidebar shows "Logout" button
    7. Test logout: Click "Logout" in sidebar, verify return to login page
    8. Test session persistence: After login, refresh browser page (F5), verify still logged in (no login prompt)
    9. Test 30-day cookie: Check browser DevTools → Application → Cookies → localhost:8501, verify cookie named "rag_auth_cookie" with expiry ~30 days from now
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] rag_web.py modified with authentication wrapper
- [ ] Login page appears on app start
- [ ] Invalid credentials show error message
- [ ] Valid credentials grant access to RAG interface
- [ ] Logout button works and returns to login
- [ ] Session persists across page refreshes
- [ ] No Python errors or warnings in console
</verification>

<success_criteria>
- All tasks completed
- Authentication integrated into rag_web.py
- Human verification passed (login/logout/session persistence all work)
- No errors or warnings when running app
- RAG functionality accessible only after authentication
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication-foundation/01-02-SUMMARY.md`
</output>
